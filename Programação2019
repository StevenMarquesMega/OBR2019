#define FRENTE 40
#define OBSTACULO 60
#define SEGUIDOR 45
#define vel_F 45
#define vel_R 48
#define RAMPA 90
#define frentao 100
#define limiar 15

//--- Fim dos parametros de controle de velocidade ---
//======================================================================================

//======================================================================================
//--- Variaveis de controle e atribuição de valores para seguidor de linha e verdes ---

int preto = 82; // menor que 82 preto
int branco = 82;// maior que 82 branco
int VD = 43;
int VE = 42;
int verde = 4;
int verde_2 = 3;
int A, B;
unsigned int VA, VB;
unsigned int ColorNum, Red, Green, Blue;
unsigned int ColorNum_2, Red_2, Green_2, Blue_2;

//--- Fim das variaveis de valores do seguidor de linha e verdes ---
//======================================================================================

//======================================================================================
//--- Variavel para controle de rotação ---

int curva = 600;
int Nov = 840;
int Vol = 1680;
int Lov = 300;
int Rotacao = 400; //Duas rotações.
int Volta = 680;
int BB;

//--- Fim da varivavel que equivale a uma rotação ---
//======================================================================================

//======================================================================================
//--- Variaveis para controle de leitura do sensor de inclinação e o sensor de toque ---

int Ultra = 0;
int Resgate = 0;

//--- Fim das variaveis para sensor de inclinação e o sensor de toque ---
//======================================================================================

//======================================================================================
//--- Função para resgate de vitimas ---

void RV();

//--- Fim da função de regate de vitimas ---
//======================================================================================

//======================================================================================
//--- Função para fazer leitura do sensor de cor HITECHNIC ---

void lerSensorDeLinha(){

    SetHTColor2Mode(IN_2, HT_CMD_COLOR2_ACTIVE);// Hi Tec
    SetSensorLowspeed(IN_2);

    SetHTColor2Mode(IN_3, HT_CMD_COLOR2_ACTIVE); // Hi Tec
    SetSensorLowspeed(IN_3);                   // Hi Tec

    ReadSensorHTColor(IN_2, ColorNum, Red, Green, Blue);// Hi Tec
    ReadSensorHTColor(IN_3, ColorNum_2, Red_2, Green_2, Blue_2);

    A = Red; //  < 82 -  menor que 82 PRETO
    B = Red_2; // > 82 - Maior que 82 BRANCO

    VA = ColorNum;
    VB = ColorNum_2;


     /*ClearScreen();
     NumOut(20, LCD_LINE2, A);//meio direita
     NumOut(20, LCD_LINE6, B);//meio esqu\erda

     NumOut(60, LCD_LINE2, VA);
     NumOut(60, LCD_LINE6, VB);
     */

     //A e D
     //B e C
}

//--- Fim da função que faz a leitura do sensor de cor ---
//======================================================================================

//======================================================================================
//--- Função para fazer leitura dos sensores: inclinação e toques ---

void lerDistancia(){

       SetSensor(IN_4, SENSOR_TOUCH);
       Ultra = Sensor(IN_4);
       //NumOut(60, LCD_LINE4, Ultra);
}
void lerResgate(){
       SetSensor(IN_1, SENSOR_TOUCH);
       Resgate = Sensor(IN_1);
       //NumOut(20, LCD_LINE4, Resgate);
}

//--- Fim da função de leitura dos sensores: inclinação e toques ---
//======================================================================================

//======================================================================================
//--- Funções para controle de locomoção dos motores do robô ---

void Garra_D(){
    OnFwd(OUT_A, 80);
}
void Garra_S(){
    OnRev(OUT_A, 80);
}
void Garra_P(){
    Off(OUT_A);
}
void  Frente(){
    OnFwd(OUT_B, FRENTE);
    OnFwd(OUT_C, FRENTE);
    lerSensorDeLinha();
    //lerDistancia();
}
void Rampa()  {
    OnFwd(OUT_B, RAMPA);
    OnFwd(OUT_C, RAMPA);
    lerSensorDeLinha();
    //lerDistancia();
}
void capoha() {
    OnFwd(OUT_B, frentao);
    OnFwd(OUT_C, frentao);
    lerSensorDeLinha();
    //lerDistancia();
}
void Tras_2()  {
    OnRev(OUT_B, FRENTE);
    OnRev(OUT_C, FRENTE);
    lerSensorDeLinha();
    //lerDistancia();
}
void Tras()  {
    OnRev(OUT_B, SEGUIDOR);
    OnRev(OUT_C, SEGUIDOR);
    lerSensorDeLinha();
    //lerDistancia();
}
void Esquerda()  {
    OnFwd(OUT_B, SEGUIDOR + limiar);
    OnRev(OUT_C, SEGUIDOR + limiar);
    lerSensorDeLinha();
    //lerDistancia();
}
void Esquerda2()  {
    OnFwd(OUT_B, SEGUIDOR);
    OnRev(OUT_C, SEGUIDOR);
    lerSensorDeLinha();
}
void Direita()  {
    OnRev(OUT_B, SEGUIDOR + limiar);
    OnFwd(OUT_C, SEGUIDOR + limiar);
    lerSensorDeLinha();
    //lerDistancia();
}
void Direita2()  {
    OnRev(OUT_B, SEGUIDOR);
    OnFwd(OUT_C, SEGUIDOR);
    lerSensorDeLinha();
    //lerDistancia();
}
void Direita_F()  {
    OnRev(OUT_B, vel_R );
    OnFwd(OUT_C, vel_F + limiar);
    lerSensorDeLinha();
    //lerDistancia();
}
void Esquerda_F()  {
    OnFwd(OUT_B, vel_F + limiar);
    OnRev(OUT_C, vel_R );
    lerSensorDeLinha();
}
void Parar()  {
    OnFwd(OUT_B, 0);
    OnFwd(OUT_C, 0);
    lerSensorDeLinha();
    //lerDistancia();
}
void curva135Direita(){
     //RotateMotorEx(‘ports',‘speed',‘degrees',‘turnpct',‘sync', 'stop')
     RotateMotorEx(OUT_BC, 60, 1.4*curva, 100, true, true);
     lerSensorDeLinha();
}
void curva135Esquerda(){
     //RotateMotorEx(‘ports',‘speed',‘degrees',‘turnpct',‘sync', 'stop')
     RotateMotorEx(OUT_BC, 50, 1.7*curva, -100, true, true);
     lerSensorDeLinha();
}

//--- Fim das funções de controle para locomoção do robô ---
//======================================================================================



//======================================================================================
//--- Função para controle e execução do seguidor de linha normal ---
void Seguidor(){

  //Branco -  Branco: Frente
  lerSensorDeLinha();
  if(A > branco && B > branco)
  {
         Frente();

         BB = MotorRotationCount(OUT_B);
         if(BB >= Rotacao){
            Parar();
            Wait(10);

            lerSensorDeLinha();
            if(A > branco && B > branco){
            Frente();
            Wait(190);
            Parar();
            Wait(10);
            Esquerda();
            Wait(300);
            Parar();
            Wait(10);

            lerSensorDeLinha();
            if(A < preto){
              Frente();}

            lerSensorDeLinha();
            if(A > branco){
              Direita();
              Wait(370);
              Parar();
              Wait(10);
            lerSensorDeLinha();
            if(B < preto){
              Frente();}

            lerSensorDeLinha();
            if(A > branco){
              OnRev(OUT_BC, 80);
              Wait(Volta);}
            }

            lerSensorDeLinha();
            if(A > branco && B > branco){
            Frente();
            Wait(190);
            Parar();
            Wait(10);
            Esquerda();
            Wait(300);
            Parar();
            Wait(10);

            lerSensorDeLinha();
            if(A < preto){
              Frente();}

            lerSensorDeLinha();
            if(A > branco){
              Direita();
              Wait(570);
              Parar();
              Wait(10);
            lerSensorDeLinha();
            if(B < preto){
              Frente();}
              
            lerSensorDeLinha();
            if(A > branco){
              OnRev(OUT_BC, 80);
              Wait(400);}
            }
         }
      }
   }
}
  //Branco - Preto: Esquerda
  if(A > branco && B < preto)
  {
         OnFwd(OUT_B, 60);
         OnRev(OUT_C, 55);

         lerSensorDeLinha();
         if(A < preto && B  < preto){
         Parar();
         Wait(10);
         while(A < preto && B  < preto){
          Frente();
          Wait(150);}
          while(!(A < preto)){
           Esquerda();}
         }
         ResetRotationCount(OUT_B);

  }
  //Preto - Branco: Direita
  if(A < preto && B > branco)
  {
         OnFwd(OUT_C, 60);
         OnRev(OUT_B, 55);

         lerSensorDeLinha();
         if(A < preto && B < preto){
         Parar();
         Wait(10);
         while(A < preto && B < preto){
          Frente();
          Wait(150);}
          while(!(B < preto)){
           Direita();}
         }
         ResetRotationCount(OUT_B);
  }

  //Preto - Preto:
  lerSensorDeLinha();
  if(A < preto && B < preto || VA == verde && VB == verde || VA == verde_2 && VB == verde_2
    || VA == verde && B < preto || VB == verde && A < preto){
   while(A < preto && B < preto || VA == verde && VB == verde || VA == verde_2 && VB == verde_2
    || VA == verde && B < preto || VB == verde && A < preto){
      Frente();
      Wait(50);}
      Parar();
      Wait(0.03);

      //Verde-falso-Direita
      lerSensorDeLinha();
      if(VA == verde || VA == verde_2 || VA == verde && B < preto){
      while(VA == verde || VA == verde_2 || VA == verde && B < preto){
       Frente();}
       if(A > branco){
       Frente();}
       ResetRotationCount(OUT_B);
      }


      //Verde-falso-Esquerda
      lerSensorDeLinha();
      if(VB == verde || VB == verde_2 || VB == verde && A < preto){
      while(VB == verde || VB == verde_2 || VB == verde && A < preto){
       Frente();}
       if(B > branco){
       Frente();}
       ResetRotationCount(OUT_B);
      }

      lerSensorDeLinha();
      //Esquerda.
      if(A < preto){
        RotateMotor(OUT_BC, 50, 0.03);
        ResetRotationCount(OUT_B);
        while(A > branco){
        Esquerda();
        BB = MotorRotationCount(OUT_B);
        if(BB >= Nov){
         Parar();}
       }
       Parar();
       if(A > branco){
         ResetRotationCount(OUT_C);
         while(B > branco){
         Direita();
         BB = MotorRotationCount(OUT_B);
         if(BB >= Vol){
         Parar();}
         }
       }

       //Direita.
      if(B < preto){
        RotateMotor(OUT_BC, 50, 0.03);
        ResetRotationCount(OUT_C);
        while(B > branco){
        Direita();
        BB = MotorRotationCount(OUT_C);
        if(BB >= Nov){
         Parar();}
       }
       Parar();
       if(B > branco){
         ResetRotationCount(OUT_B);
         while(A > branco){
         Esquerda();
         BB = MotorRotationCount(OUT_C);
         if(BB >= Vol){
         Parar();}
         }

       //Encruzilhada.
       RotateMotor(OUT_BC, 50, 0.03);
       ResetRotationCount(OUT_B);
       while(A > branco){
         Esquerda();
         BB = MotorRotationCount(OUT_B);
         if(BB >= Lov){
         Parar();}
         }
         if(A < preto){
          Direita();
          Wait(100);
          Parar();
          Wait(10);
          Tras();
          Wait(1);
         }
       }

      }
    }
  }
}
//======================================================================================
//--- Função para detectar os verdes antes do seguidor normal ---


void seguidorVerde(){
       lerSensorDeLinha();

    //---Verde Verde---
  if ((VA == verde || VB == verde) || (VA == verde_2 || VB == verde_2)){
         Parar();
         Wait(100);}

         //---Verde Verdadeiro---
         lerSensorDeLinha();
      if((VA == verde && VB == verde) || (VA == verde_2 && VB == verde_2)){
         while((VA == verde && VB == verde) || (VA == verde_2 && VB == verde_2)){
         Frente();}

         lerSensorDeLinha();
      if((A < preto && B < preto) || (A < preto) || (B < preto)){
         Frente();
         Wait(150);
         Parar();}

         lerSensorDeLinha();
      if((A > branco && B > branco) || (A > branco) || (B > branco)){
         Parar();
         Wait(10);}

            curva135Direita();
            Tras();
            Wait(15);
            ResetRotationCount(OUT_B);

         }

    //---Verde Direita---
    lerSensorDeLinha();
    if((VA == verde) || (VA == verde_2)
    || (VA == VD) || (VA == VE)){
       Parar();
       Wait(10);

    if((VB == verde) || (VB == verde_2)){
       lerSensorDeLinha();
         if(A < preto || B < preto){
         while(A < preto || B < preto){
         Frente();
         Wait(150);}//fim do 2 while
         }//fim do 2 if

            curva135Direita();
            Tras();
            Wait(15);
            ResetRotationCount(OUT_B);
     }
    while(VA == verde || VA == verde_2 || VA == VD  || VA == VE ){
       Tras();
       Wait(100);}
       lerSensorDeLinha();
       if(A > branco){
       lerSensorDeLinha();
       while(A > branco){
       Frente();}
       }
       lerSensorDeLinha();
       if((VA == verde) || (VA == verde_2)
       || (VA == VD) || (VA == VE)){
       lerSensorDeLinha();
       while((VA == verde) || (VA == verde_2)
       || (VA == VD) || (VA == VE)){
       Frente();}
       }
       lerSensorDeLinha();
       if(A < preto){
         Frente();
         Wait(250);}
        lerSensorDeLinha();
        if(A > branco || A < preto){
         RotateMotorEx(OUT_BC, 60, 370, 100, true, true);
         Parar();
         Wait(10);
         Tras_2();
         Wait(15);
         Frente();
         Wait(5);

         ResetRotationCount(OUT_B);
        }
        if(VA == verde || VA == verde_2){
        while(VA == verde || VA == verde_2){
        Frente();}
        if(A > branco){
        Frente();}
        ResetRotationCount(OUT_C);}
    }

    lerSensorDeLinha();
    //---Verde Esquerda---
    if ((VB == verde) || (VB == verde_2)
     || (VB == VD)  || (VB == VE)) {
       Parar();
       Wait(10);

    if((VA == verde) || (VA == verde_2)){
      lerSensorDeLinha();
         if(A < preto || B < preto){
         while(A < preto || B < preto){
         Frente();
         Wait(100);}//fim do 2 while
         }//fim do 2 if

            curva135Direita();
            Tras();
            Wait(15);
            ResetRotationCount(OUT_B);
    }
    while(VB == verde || VB == verde_2 || VA == VD || VA == VE){
       Tras();
       Wait(100);}
       lerSensorDeLinha();
       if(A < preto && B < preto){
       while(A < preto && B < preto){
       Frente();}
       if(VB== verde || VB == verde_2 || VB == VD  || VB == VE){
       Frente();}
       }
       if(B > branco){
       lerSensorDeLinha();
       while(B > branco){
       Frente();}
       }
       lerSensorDeLinha();
       if ((VB == verde) || (VB == verde_2)
        || (VB == VD)  || (VB == VE)){
       lerSensorDeLinha();
       while((VB == verde) || (VB == verde_2)
        || (VB == VD)  || (VB == VE)){
        Frente();}
        }
       lerSensorDeLinha();
       if(B < preto){
         Frente();
         Wait(250);}
        lerSensorDeLinha();
        if(B > branco || B < preto){
         RotateMotorEx(OUT_BC, 60, 370, -100, true, true);
         Parar();
         Wait(10);
         Tras_2();
         Wait(15);
         Frente();
         Wait(5);

         ResetRotationCount(OUT_B);
         }
        //---Verde falso---
       if(VB == verde || VB == verde_2){
       while(VB == verde || VB == verde_2){
        Frente();}
       if(B > branco){
        Frente();}
       }
    }
       Seguidor();
  }
//======================================================================================
//--- Funções para controle dos motores que desvia do obstaculo com mais velocidade ---

void  Frente_O()  {
    OnFwd(OUT_C, OBSTACULO);
    OnFwd(OUT_B, OBSTACULO);
    lerSensorDeLinha();
    //lerDistancia();
  }
void Tras_O() {
    OnRev(OUT_C, OBSTACULO);
    OnRev(OUT_B, OBSTACULO);
    lerSensorDeLinha();
    //lerDistancia();
  }
void Esquerda_O()  {
    OnFwd(OUT_B, OBSTACULO);
    OnRev(OUT_C, OBSTACULO);
    lerSensorDeLinha();
    //lerDistancia();
  }
void Direita_O()  {
    OnRev(OUT_B, OBSTACULO);
    OnFwd(OUT_C, OBSTACULO);
    lerSensorDeLinha();
    //lerDistancia();
  }

//======================================================================================
//--- Função para desvio de obstaculo para os dois lados ---
void desvioEsquerda(){

     lerSensorDeLinha();
      //Esquerda
      Tras();
      Wait(800);
      Parar();
      Wait(100);
      Esquerda_O();
      Wait(1000);
      Parar();
      Wait(100);
      Frente_O();
      Wait(500);
      Parar();
      Wait(10);
      OnFwd(OUT_B, 20);
      OnFwd(OUT_C, 80);
      Wait(2100);
      Parar();
      Wait(10);
      Frente_O();
      Wait(1200);
      Parar();
      Wait(10);
      OnFwd(OUT_B, 10);
      OnFwd(OUT_C, 100);
      Wait(1500);
      ResetRotationCount(OUT_B);
      
      lerSensorDeLinha();
      if(A > branco || B > branco){
      while(A > branco || B > branco){
         Frente();}
      }
      lerSensorDeLinha();
      if(A < preto || B < preto){
         Frente();
         Wait(600);
         Parar();
         Wait(10);}
         lerSensorDeLinha();
         if(A > branco){
         Esquerda();
         Wait(1200);
          Tras();
          Wait(5);
          ResetRotationCount(OUT_B);
         }
lerSensorDeLinha();
}

void desvioDireita(){

     lerSensorDeLinha();
      //Direita
      Tras();
      Wait(800);
      Parar();
      Wait(100);
      Direita_O();
      Wait(1000);
      Parar();
      Wait(100);
      Frente_O();
      Wait(500);
      Parar();
      Wait(10);
      OnFwd(OUT_C, 20);
      OnFwd(OUT_B, 80);
      Wait(2100);
      Parar();
      Wait(10);
      Frente_O();
      Wait(1200);
      Parar();
      Wait(10);
      OnFwd(OUT_C, 10);
      OnFwd(OUT_B, 100);
      Wait(1500);
      
      lerSensorDeLinha();
      if(A > branco || B > branco){
      while(A > branco || B > branco){
         Frente();}
      }
          
      lerSensorDeLinha();
      if(A < preto || B < preto){
         Frente();
         Wait(600);
         Parar();
         Wait(10);}
         lerSensorDeLinha();
         if(B > branco){
         Direita();
         Wait(1200);
          Tras();
          Wait(5);
          ResetRotationCount(OUT_B);
         }
lerSensorDeLinha();
}

//--- Fim da função desvio de obstaculo ---
//======================================================================================

//======================================================================================
//--- Função dos Triangulos no resgate ---
void t_1(){

       lerResgate();
      //resgate após o toque
      Tras_O();
      Wait(50);
      Parar();
      Wait(3);
      Esquerda_O();
      Wait(300);
      Parar();
      Wait(3);
      RotateMotor(OUT_BC, 100, 3500);
      Parar();
      Wait(3);
      lerResgate();
       if(Resgate == 0){
        RV();
      }

      Parar();
      Wait(3);
      OnRev(OUT_B, 90);
      OnRev(OUT_C, 30);
      Wait(1800);
      Parar();
      Wait(3);
      Tras();
      Wait(1000);
      Parar();
      Wait(3);
      OnRev(OUT_C, 10);
      OnFwd(OUT_B, 100);
      Wait(1040);
      Parar();
      Wait(3);

      //Soltar vitimias

      Garra_D();
      Wait(1000);
      Garra_P();
      Wait(3);

        lerResgate();
        if(Resgate == 1){
         OnRev(OUT_BC, 90);
         Wait(1000);

        lerResgate();
        if(Resgate == 0){
         Parar();
         Wait(1000);
         Frente();
         Wait(600);}

        lerResgate();
        if(Resgate == 1){
         OnRev(OUT_BC, 90);
         Wait(1000);}

        lerResgate();
        if(Resgate == 0){
         Parar();
         Wait(1000);
         Frente();
         Wait(600);}

        lerResgate();
        if(Resgate == 1){
         OnRev(OUT_BC, 90);
         Wait(1000);}

        lerResgate();
        if(Resgate == 0){
         Parar();
         Wait(1000);
         Frente();
         Wait(600);
         Parar();
         Wait(10);}
         }

      Direita();
      Wait(1100);
      Parar();
      Wait(3);
      RotateMotor(OUT_BC, 100, 1900);
      Parar();
      Wait(3);

      //Testar 2 Parede depois do triangulo
      lerResgate();
       if(Resgate == 0){
        RV();
      }

      Parar();
      Wait(3);
      OnFwd(OUT_B, 100);
      OnRev(OUT_C, 10);
      Wait(400);
      Parar();
      Wait(3);
      OnFwd(OUT_BC, 100);
      Wait(250);
      Parar();
      Wait(3);
      OnFwd(OUT_B, 100);
      OnRev(OUT_C, 10);
      Wait(1400);
      Parar();
      Wait(3);
      Tras_O();
      Wait(900);
      Parar();
      Wait(3);
      Garra_D();
      Wait(1000);
      Garra_P();
      Wait(3);
      Direita();
      Wait(500);
      Parar();
      Wait(2);

      //Testar 3 Parede
      RotateMotor(OUT_BC, 100, 2500);
      Parar();
      Wait(3);
      lerResgate();
       if(Resgate == 0){
       RV();
      }

      Parar();
      Wait(3);
      OnFwd(OUT_B, 100);
      OnRev(OUT_C, 10);
      Wait(400);
      Parar();
      Wait(3);
      OnFwd(OUT_BC, 100);
      Wait(250);
      Parar();
      Wait(3);
      OnFwd(OUT_B, 100);
      OnRev(OUT_C, 10);
      Wait(1400);
      Parar();
      Wait(3);
      Tras_O();
      Wait(900);
      Parar();
      Wait(3);
      Garra_D();
      Wait(1000);
      Garra_P();
      Wait(3);
      Direita();
      Wait(500);
      Parar();
      Wait(2);

      //Testar madeira
      RotateMotor(OUT_BC, 100, 900);
      Parar();
      Wait(3);
      lerResgate();
       if(Resgate == 0){
       Tras_O();
       Wait(250);
       Parar();
       Wait(3);
       Esquerda_O();
       Wait(550);
       Parar();
       Wait(3);
       Frente_O();
       Wait(300);
       Parar();
       Wait(3);
       Direita_O();
       Wait(200);
       Parar();
       Wait(3);
      }
      if(Resgate == 1){
        Esquerda();
        Wait(100);
        Parar();
        Wait(3);}

      RotateMotor(OUT_BC, 100, 1400);
      Parar();
      Wait(3);

      //Testar 4 parede
      lerResgate();
       if(Resgate == 0){
       RV();
      }
      Parar();
      Wait(3);
      RotateMotor(OUT_B, 100, 400);
      Parar();
      Wait(3);
      Garra_D();
      Wait(1000);
      Garra_P();
      Wait(3);
      RotateMotor(OUT_BC, 100, 1400);
      lerResgate();

       //Teste de trinagulo de volta.
       if(Resgate == 0){
        Parar();
        Wait(3);
        Tras();
        Wait(20);
        Garra_S();
        Wait(2000);
        Garra_P();
        Wait(3);
        Esquerda_O();
        Wait(600);
        Parar();
        Wait(3);
        Rampa();
        Wait(1600);
        Parar();
        Wait(3);
        Esquerda_O();
        Wait(1800);
        Parar();
        Wait(3);

        //Soltar vitimias

      Garra_D();
      Wait(1000);
      Garra_P();
      Wait(3);

        lerResgate();
        if(Resgate == 1){
         OnRev(OUT_BC, 90);
         Wait(1000);

        lerResgate();
        if(Resgate == 0){
         Parar();
         Wait(1000);
         Frente();
         Wait(600);}

        lerResgate();
        if(Resgate == 1){
         OnRev(OUT_BC, 90);
         Wait(1000);}

        lerResgate();
        if(Resgate == 0){
         Parar();
         Wait(1000);
         Frente();
         Wait(600);}

        lerResgate();
        if(Resgate == 1){
         OnRev(OUT_BC, 90);
         Wait(1000);}

        lerResgate();
        if(Resgate == 0){
         Parar();
         Wait(1000);
         Frente();
         Wait(600);
         Parar();
         Wait(10);}
         }


      //---Repetir Resgate T_1---
  repeat(2){

      Direita();
      Wait(1100);
      Parar();
      Wait(3);
      RotateMotor(OUT_BC, 100, 1990);
      Parar();
      Wait(3);

      //Testar 2 Parede depois do triangulo.
      lerResgate();
       if(Resgate == 0){
        RV();
      }

      OnFwd(OUT_B, 100);
      OnRev(OUT_C, 10);
      Wait(400);
      Parar();
      Wait(3);
      OnFwd(OUT_BC, 100);
      Wait(250);
      Parar();
      Wait(3);
      OnFwd(OUT_B, 100);
      OnRev(OUT_C, 10);
      Wait(1400);
      Parar();
      Wait(3);
      Tras_O();
      Wait(900);
      Parar();
      Wait(3);
      Garra_D();
      Wait(1000);
      Garra_P();
      Wait(3);
      Direita();
      Wait(500);
      Parar();
      Wait(2);

      //Testar 3 Parede
      RotateMotor(OUT_BC, 100, 2500);
      Parar();
      Wait(3);
      lerResgate();
       if(Resgate == 0){
       RV();
      }

      OnFwd(OUT_B, 100);
      OnRev(OUT_C, 10);
      Wait(400);
      Parar();
      Wait(3);
      OnFwd(OUT_BC, 100);
      Wait(250);
      Parar();
      Wait(3);
      OnFwd(OUT_B, 100);
      OnRev(OUT_C, 10);
      Wait(1400);
      Parar();
      Wait(3);
      Tras_O();
      Wait(900);
      Parar();
      Wait(3);
      Garra_D();
      Wait(1000);
      Garra_P();
      Wait(3);
      Direita();
      Wait(500);
      Parar();
      Wait(2);

      //Testar madeira
      RotateMotor(OUT_BC, 100, 900);
      Parar();
      Wait(3);
      lerResgate();
       if(Resgate == 0){
       Tras_O();
       Wait(250);
       Parar();
       Wait(3);
       Esquerda_O();
       Wait(550);
       Parar();
       Wait(3);
       Frente_O();
       Wait(300);
       Parar();
       Wait(3);
       Direita_O();
       Wait(200);
       Parar();
       Wait(3);
      }
      if(Resgate == 1){
        Esquerda();
        Wait(100);
        Parar();
        Wait(3);}

      RotateMotor(OUT_BC, 100, 1400);
      Parar();
      Wait(3);

      //Testar 4 parede
      lerResgate();
       if(Resgate == 0){
       RV();
      }

      RotateMotor(OUT_B, 100, 400);
      Parar();
      Wait(3);
      Garra_D();
      Wait(1000);
      Garra_P();
      Wait(3);
      RotateMotor(OUT_BC, 100, 1400);
      lerResgate();

       //Teste de trinagulo de volta.
       if(Resgate == 0){
        Parar();
        Wait(3);
        Tras();
        Wait(20);
        Garra_S();
        Wait(2000);
        Garra_P();
        Wait(3);
        Esquerda_O();
        Wait(600);
        Parar();
        Wait(3);
        Rampa();
        Wait(1600);
        Parar();
        Wait(3);
        Esquerda_O();
        Wait(1800);
        Parar();
        Wait(3);

        //Soltar vitimias
      Garra_D();
      Wait(1000);
      Garra_P();
      Wait(3);

        lerResgate();
        if(Resgate == 1){
         OnRev(OUT_BC, 90);
         Wait(1000);

        lerResgate();
        if(Resgate == 0){
         Parar();
         Wait(1000);
         Frente();
         Wait(600);}

        lerResgate();
        if(Resgate == 1){
         OnRev(OUT_BC, 90);
         Wait(1000);}

        lerResgate();
        if(Resgate == 0){
         Parar();
         Wait(1000);
         Frente();
         Wait(600);}

        lerResgate();
        if(Resgate == 1){
         OnRev(OUT_BC, 90);
         Wait(1000);}

        lerResgate();
        if(Resgate == 0){
         Parar();
         Wait(1000);
         Frente();
         Wait(600);
         Parar();
         Wait(10);}
         }
        }
      }
    }

}

void t_2(){

      //---teste parede 3
      Tras();
      Wait(1);
      Parar();
      Wait(3);
      Esquerda();
      Wait(200);
      Parar();
      Wait(3);
      RotateMotor(OUT_BC, 100, 3500);
      Parar();
      Wait(3);
      lerResgate();
      if(Resgate == 0){
         RV();}

      OnRev(OUT_B, 90);
      OnRev(OUT_C, 30);
      Wait(1970);
      Parar();
      Wait(3);
      Tras();
      Wait(1000);
      Parar();
      Wait(3);
      OnRev(OUT_C, 100);
      OnFwd(OUT_B, 100);
      Wait(970);
      Parar();
      Wait(3);

     //Soltar vitimias
     Garra_D();
     Wait(1000);
     Garra_P();
     Wait(3);

        lerResgate();
        if(Resgate == 1){
         OnRev(OUT_BC, 90);
         Wait(1000);

        lerResgate();
        if(Resgate == 0){
         Parar();
         Wait(1000);
         Frente();
         Wait(600);}

        lerResgate();
        if(Resgate == 1){
         OnRev(OUT_BC, 90);
         Wait(1000);}

        lerResgate();
        if(Resgate == 0){
         Parar();
         Wait(1000);
         Frente();
         Wait(600);}

        lerResgate();
        if(Resgate == 1){
         OnRev(OUT_BC, 90);
         Wait(1000);}

        lerResgate();
        if(Resgate == 0){
         Parar();
         Wait(1000);
         Frente();
         Wait(600);
         Parar();
         Wait(10);}
         }

      Direita();
      Wait(1100);
      Parar();
      Wait(3);

      RotateMotor(OUT_BC, 100, 2000);
      Parar();
      Wait(3);

      //Testar 3 Parede depois do triangulo.
      lerResgate();
       if(Resgate == 0){
        RV();
      }

      OnFwd(OUT_B, 100);
      OnRev(OUT_C, 10);
      Wait(400);
      Parar();
      Wait(3);
      OnFwd(OUT_BC, 100);
      Wait(250);
      Parar();
      Wait(3);
      OnFwd(OUT_B, 100);
      OnRev(OUT_C, 10);
      Wait(1400);
      Parar();
      Wait(3);
      Tras_O();
      Wait(900);
      Parar();
      Wait(3);
      Garra_D();
      Wait(1000);
      Garra_P();
      Wait(3);
      Direita();
      Wait(500);
      Parar();
      Wait(2);

      //Testar madeira
      RotateMotor(OUT_BC, 100, 900);
      Parar();
      Wait(3);
      lerResgate();
       if(Resgate == 0){
       Tras_O();
       Wait(250);
       Parar();
       Wait(3);
       Esquerda_O();
       Wait(550);
       Parar();
       Wait(3);
       Frente_O();
       Wait(300);
       Parar();
       Wait(3);
       Direita_O();
       Wait(200);
       Parar();
       Wait(3);
      }
      if(Resgate == 1){
        Esquerda();
        Wait(100);
        Parar();
        Wait(3);}

      RotateMotor(OUT_BC, 100, 1100);
      Parar();
      Wait(3);

      //Testar 4 parede
      lerResgate();
       if(Resgate == 0){
       RV();
      }

      RotateMotor(OUT_B, 100, 400);
      Parar();
      Wait(3);
      Garra_D();
      Wait(1000);
      Garra_P();
      Wait(3);
      RotateMotor(OUT_BC, 100, 1400);
      lerResgate();

     //Testar parede senão houver o
     lerResgate();
     if(Resgate == 1){
     RotateMotor(OUT_BC, 100, 1200);
     Parar();
     Wait(3);}//fim do 1 if

     //Testar parede 1
     lerResgate();
     if(Resgate == 0){
      RV();}

      //apos o toque
      Parar();
      Wait(3);
      OnFwd(OUT_B, 100);
      OnRev(OUT_C, 10);
      Wait(400);
      Parar();
      Wait(3);
      OnFwd(OUT_BC, 100);
      Wait(250);
      Parar();
      Wait(3);
      OnFwd(OUT_B, 100);
      OnRev(OUT_C, 10);
      Wait(1400);
      Parar();
      Wait(3);
      Tras_O();
      Wait(900);
      Parar();
      Wait(3);
      Garra_D();
      Wait(1000);
      Garra_P();
      Wait(3);
      Direita();
      Wait(500);
      Parar();
      Wait(2);

      //Testar Triangulo t_2
      RotateMotor(OUT_BC, 70, 950);
      Parar();
      Wait(3);

      lerResgate();
      if(Resgate == 0){
      Tras();
      Wait(300);
      Parar();
      Wait(3);
      Esquerda();
      Wait(400);
      Parar();
      Wait(3);
      RotateMotor(OUT_BC, 100, 1000);
      Parar();
      Wait(3);}

      OnRev(OUT_C, 80);
      OnFwd(OUT_B, 100);
      Wait(1100);
      Parar();
      Wait(3);

     //Soltar vitimias

     Garra_D();
     Wait(1000);
     Garra_P();
     Wait(3);

        lerResgate();
        if(Resgate == 1){
         OnRev(OUT_BC, 90);
         Wait(1200);

        lerResgate();
        if(Resgate == 0){
         Parar();
         Wait(1000);
         Frente();
         Wait(600);}

        lerResgate();
        if(Resgate == 1){
         OnRev(OUT_BC, 90);
         Wait(1100);}

        lerResgate();
        if(Resgate == 0){
         Parar();
         Wait(1000);
         Frente();
         Wait(600);}

        lerResgate();
        if(Resgate == 1){
         OnRev(OUT_BC, 90);
         Wait(1000);}

        lerResgate();
        if(Resgate == 0){
         Parar();
         Wait(1000);
         Frente();
         Wait(600);
         Parar();
         Wait(3);}
 }

   //---Resgate duas vezes---
   repeat(2){

      Direita();
      Wait(1100);
      Parar();
      Wait(3);

      RotateMotor(OUT_BC, 100, 2000);
      Parar();
      Wait(3);

      //Testar 3 Parede depois do triangulo.
      Parar();
      Wait(3);
      lerResgate();
       if(Resgate == 0){
        RV();
      }

      OnFwd(OUT_B, 100);
      OnRev(OUT_C, 10);
      Wait(400);
      Parar();
      Wait(3);
      OnFwd(OUT_BC, 100);
      Wait(250);
      Parar();
      Wait(3);
      OnFwd(OUT_B, 100);
      OnRev(OUT_C, 10);
      Wait(1400);
      Parar();
      Wait(3);
      Tras_O();
      Wait(900);
      Parar();
      Wait(3);
      Garra_D();
      Wait(1000);
      Garra_P();
      Wait(3);
      Direita();
      Wait(500);
      Parar();
      Wait(2);

      //Testar madeira
      RotateMotor(OUT_BC, 100, 900);
      Parar();
      Wait(3);
      lerResgate();
       if(Resgate == 0){
       Tras_O();
       Wait(250);
       Parar();
       Wait(1);
       Esquerda_O();
       Wait(550);
       Parar();
       Wait(3);
       Frente_O();
       Wait(300);
       Parar();
       Wait(3);
       Direita_O();
       Wait(200);
       Parar();
       Wait(3);
      }
      if(Resgate == 1){
        Esquerda();
        Wait(100);
        Parar();
        Wait(3);}

      RotateMotor(OUT_BC, 100, 1400);
      Parar();
      Wait(3);

      //Testar 4 parede
      lerResgate();
       if(Resgate == 0){
       RV();
      }
      
      RotateMotor(OUT_B, 100, 400);
      Parar();
      Wait(3);
      Garra_D();
      Wait(1000);
      Garra_P();
      Wait(3);
      RotateMotor(OUT_BC, 100, 1400);
      lerResgate();

     //Testar parede senão houver o
     lerResgate();
     if(Resgate == 1){
     RotateMotor(OUT_BC, 100, 1200);
     Parar();
     Wait(3);}//fim do 1 if

     //Testar parede 1
     lerResgate();
     if(Resgate == 0){
      RV();}

      //apos o toque
      OnFwd(OUT_B, 100);
      OnRev(OUT_C, 10);
      Wait(400);
      Parar();
      Wait(3);
      OnFwd(OUT_BC, 100);
      Wait(250);
      Parar();
      Wait(3);
      OnFwd(OUT_B, 100);
      OnRev(OUT_C, 10);
      Wait(1400);
      Parar();
      Wait(3);
      Tras_O();
      Wait(900);
      Parar();
      Wait(3);
      Garra_D();
      Wait(1000);
      Garra_P();
      Wait(3);
      Direita();
      Wait(500);
      Parar();
      Wait(2);

      //Testar Triangulo t_2
      RotateMotor(OUT_BC, 70, 1100);
      Parar();
      Wait(3);

      lerResgate();
      if(Resgate == 0){
      Tras();
      Wait(300);
      Parar();
      Wait(3);
      Esquerda();
      Wait(460);
      Parar();
      Wait(3);
      RotateMotor(OUT_BC, 100, 1000);
      Parar();
      Wait(3);}

      OnRev(OUT_C, 90);
      OnFwd(OUT_B, 100);
      Wait(1100);
      Parar();
      Wait(3);

     //Soltar vitimias
     Garra_D();
     Wait(1000);
     Garra_P();
     Wait(3);

        lerResgate();
        if(Resgate == 1){
         OnRev(OUT_BC, 90);
         Wait(1000);

        lerResgate();
        if(Resgate == 0){
         Parar();
         Wait(1000);
         Frente();
         Wait(600);}

        lerResgate();
        if(Resgate == 1){
         OnRev(OUT_BC, 90);
         Wait(1000);}

        lerResgate();
        if(Resgate == 0){
         Parar();
         Wait(1000);
         Frente();
         Wait(600);}

        lerResgate();
        if(Resgate == 1){
         OnRev(OUT_BC, 90);
         Wait(1000);}

        lerResgate();
        if(Resgate == 0){
         Parar();
         Wait(1000);
         Frente();
         Wait(600);
         Parar();
         Wait(10);}
         }
     }
}

void t_3(){

      lerResgate();
      Tras();
      Wait(10);
      Parar();
      Wait(3);
      Esquerda();
      Wait(400);
      Parar();
      Wait(3);
      RotateMotor(OUT_BC, 100, 1000);
      Parar();
      Wait(3);

      //Testar madeira
      RotateMotor(OUT_BC, 100, 700);
      Parar();
      Wait(3);
      lerResgate();
       if(Resgate == 0){
       Tras_O();
       Wait(250);
       Parar();
       Wait(3);
       Esquerda_O();
       Wait(550);
       Parar();
       Wait(3);
       Frente_O();
       Wait(300);
       Parar();
       Wait(3);
       Direita_O();
       Wait(200);
       Parar();
       Wait(3);
      }
      if(Resgate == 1){
        Esquerda();
        Wait(300);
        Parar();
        Wait(3);}

      RotateMotor(OUT_BC, 100, 1100);
      Parar();
      Wait(3);

      //Testar 4 parede
      lerResgate();
       if(Resgate == 0){
       RV();
      }

      OnRev(OUT_B, 90);
      OnRev(OUT_C, 30);
      Wait(1600);
      Parar();
      Wait(3);
      Tras();
      Wait(800);
      Parar();
      Wait(3);
      OnRev(OUT_C, 100);
      OnFwd(OUT_B, 90);
      Wait(750);
      Parar();
      Wait(3);

     //Soltar vitimias
     Garra_D();
     Wait(1000);
     Garra_P();
     Wait(3);

        lerResgate();
        if(Resgate == 1){
         OnRev(OUT_BC, 90);
         Wait(1000);

        lerResgate();
        if(Resgate == 0){
         Parar();
         Wait(1000);
         Frente();
         Wait(600);}

        lerResgate();
        if(Resgate == 1){
         OnRev(OUT_BC, 90);
         Wait(1000);}

        lerResgate();
        if(Resgate == 0){
         Parar();
         Wait(1000);
         Frente();
         Wait(600);}

        lerResgate();
        if(Resgate == 1){
         OnRev(OUT_BC, 90);
         Wait(1000);}

        lerResgate();
        if(Resgate == 0){
         Parar();
         Wait(1000);
         Frente();
         Wait(600);
         Parar();
         Wait(10);}
         }

    //Resgate 2 VAR.
    repeat(2){
         lerResgate();

         Direita();
         Wait(1100);
         Parar();
         Wait(3);

         //Testar madeira
         RotateMotor(OUT_BC, 100, 800);
         Parar();
         Wait(3);
         lerResgate();
         if(Resgate == 0){
         Tras_O();
         Wait(250);
         Parar();
         Wait(3);
         Esquerda_O();
         Wait(550);
         Parar();
         Wait(3);
         Frente_O();
         Wait(300);
         Parar();
         Wait(3);
         Direita_O();
         Wait(200);
         Parar();
         Wait(3);
      }
         if(Resgate == 1){
         Esquerda();
         Wait(300);
         Parar();
         Wait(3);}

         RotateMotor(OUT_BC, 100, 1100);
         Parar();
         Wait(3);

         //Testar 4 parede
         lerResgate();
         if(Resgate == 0){
          RV();}

         RotateMotor(OUT_B, 100, 400);
         Parar();
         Wait(3);

         Garra_D();
         Wait(1000);
         Garra_P();
         Wait(3);
         Direita();
         Wait(300);
         Parar();
         Wait(3);

         RotateMotor(OUT_BC, 100, 2400);
         Parar();
         Wait(3);

         lerResgate();
         if(Resgate == 0){
           RV();}

         OnFwd(OUT_B, 100);
         OnRev(OUT_C, 10);
         Wait(400);
         Parar();
         Wait(3);
         OnFwd(OUT_BC, 100);
         Wait(250);
         Parar();
         Wait(3);
         OnFwd(OUT_B, 100);
         OnRev(OUT_C, 10);
         Wait(1400);
         Parar();
         Wait(3);
         Tras_O();
         Wait(900);
         Parar();
         Wait(3);
         
         Garra_D();
         Wait(1000);
         Garra_P();
         Wait(3);
         Direita();
         Wait(500);
         Parar();
         Wait(2);

         RotateMotor(OUT_BC, 100, 2400);
         Parar();
         Wait(3);

         lerResgate();
         if(Resgate == 0){
          RV();}

         OnFwd(OUT_B, 100);
         OnRev(OUT_C, 10);
         Wait(400);
         Parar();
         Wait(3);
         OnFwd(OUT_BC, 100);
         Wait(250);
         Parar();
         Wait(3);
         OnFwd(OUT_B, 100);
         OnRev(OUT_C, 10);
         Wait(1400);
         Parar();
         Wait(3);
         Tras_O();
         Wait(900);
         Parar();
         Wait(3);

         Garra_D();
         Wait(1000);
         Garra_P();
         Wait(3);
         Direita();
         Wait(500);
         Parar();
         Wait(2);
         RotateMotor(OUT_BC, 100, 1600);
         Parar();
         Wait(3);

         lerResgate();
         if(Resgate ==  0){
          Tras();
          Wait(300);
          Parar();
          Wait(3);
          Esquerda();
          Wait(460);
          Parar();
          Wait(3);
          RotateMotor(OUT_BC, 100, 1000);
          Parar();
          Wait(3);}

          OnRev(OUT_C, 80);
          OnFwd(OUT_B, 90);
          Wait(940);
          Parar();
          Wait(3);

          //Soltar vitimias

          lerResgate();
          if(Resgate == 1){
          OnRev(OUT_BC, 90);
          Wait(1000);

          lerResgate();
          if(Resgate == 0){
          Parar();
          Wait(1000);
          Frente();
          Wait(600);}

          lerResgate();
          if(Resgate == 1){
          OnRev(OUT_BC, 90);
          Wait(1000);}

          lerResgate();
          if(Resgate == 0){
          Parar();
          Wait(1000);
          Frente();
          Wait(600);}

          lerResgate();
          if(Resgate == 1){
          OnRev(OUT_BC, 90);
          Wait(1000);}

          lerResgate();
          if(Resgate == 0){
          Parar();
          Wait(1000);
          Frente();
          Wait(600);
          Parar();
          Wait(10);}
        }
    }
}

//--- Fim das funções dos Triangulos ---
//======================================================================================

//======================================================================================
//--- Função para fazer o Resgate de vitimas ---

void RV(){

   Tras();
   OnRev(OUT_A, 99);
   Wait(1600);
   Garra_P();
   Wait(3);

   lerResgate();
}

//--- Fim da função para o Resgate de vitimas ---
//======================================================================================

//======================================================================================
//--- Resgate após ah rampa ---
void ResInicio(){

     lerResgate();
     Rampa();
     Wait(1300);
     Parar();
     Wait(10);
     RotateMotor(OUT_B, 100, 460);
     Parar();
     Wait(10);
     RotateMotor(OUT_C, 100, -200);
     Parar();
     Wait(10);
     Esquerda_O();
     Wait(350);
     Tras_O();
     Wait(800);
     Parar();
     Wait(10);
     Garra_D();
     Wait(1000);
     Garra_P();
     Wait(10);

     //Meio da sala de resgate
     RotateMotor(OUT_BC, 100, 1900);
     //Testar Parede.
     lerResgate();
     if(Resgate == 0){
     RV();}

     Parar();
     Wait(10);
     RotateMotor(OUT_BC, 100, -1460);
     Parar();
     Wait(10);
     Frente();
     Wait(50);
     Parar();
     Wait(10);
     Direita_O();
     Wait(1670);
     Parar();
     Wait(10);
     OnRev(OUT_BC, 100);
     Wait(900);
     Parar();
     Wait(3);
     Garra_D();
     Wait(1000);
     Garra_P();
     Wait(10);
     Direita_O();
     Wait(250);
     Parar();
     Wait(3);

     //Testar Triangulo t_1
     RotateMotor(OUT_BC, 60, 950);
     Parar();
     Wait(3);
     lerResgate();
     if(Resgate == 0){
       t_1();}


     //Testar parede senão houver o t_1
     lerResgate();
     if(Resgate == 1){
     RotateMotor(OUT_BC, 100, 1100);
     Parar();
     Wait(3);}//fim do 1 if

     //Testar parede 1
     lerResgate();
     if(Resgate == 0){
      RV();}

      //apos o toque
      Parar();
      Wait(3);
      OnFwd(OUT_B, 100);
      OnRev(OUT_C, 10);
      Wait(400);
      Parar();
      Wait(3);
      OnFwd(OUT_BC, 100);
      Wait(250);
      Parar();
      Wait(3);
      OnFwd(OUT_B, 100);
      OnRev(OUT_C, 10);
      Wait(1400);
      Parar();
      Wait(3);
      OnRev(OUT_BC, 100);
      Wait(500);
      Parar();
      Wait(3);
      Garra_D();
      Wait(1000);
      Garra_P();
      Wait(3);
      Direita();
      Wait(400);
      Parar();
      Wait(3);

      //Testar Triangulo t_2
      RotateMotor(OUT_BC, 60, 950);
      Parar();
      Wait(3);
      lerResgate();
      if(Resgate == 0){
         t_2();
      }

      //se não houver triangulo no T_2
      lerResgate();
      if(Resgate == 1){
         RotateMotor(OUT_BC, 100, 1400);
         Parar();
         Wait(3);}

     //Testar parede 2
     lerResgate();
     if(Resgate == 0){
     RV();}

     //apos o toque
      Parar();
      Wait(3);
      OnFwd(OUT_B, 100);
      OnRev(OUT_C, 10);
      Wait(400);
      Parar();
      Wait(3);
      OnFwd(OUT_BC, 100);
      Wait(250);
      Parar();
      Wait(3);
      OnFwd(OUT_B, 100);
      OnRev(OUT_C, 10);
      Wait(1400);
      Parar();
      Wait(3);
      OnRev(OUT_BC, 100);
      Wait(500);
      Parar();
      Wait(3);
      Garra_D();
      Wait(1000);
      Garra_P();
      Wait(3);
      Direita();
      Wait(400);
      Parar();
      Wait(3);

      //Testar Triangulo t_3
      RotateMotor(OUT_BC, 70, 1100);
      Parar();
      Wait(3);
      lerResgate();
      if(Resgate == 0){
         t_3();
      }

     lerResgate();
     lerDistancia();
     lerSensorDeLinha();
}
//--- Fim da função resgate apos a rampa ---
//======================================================================================


//======================================================================================
//--- Função para o seguidor da rampa ---

void seguidorRampa(){
 lerSensorDeLinha();
 if(A  > branco && B > branco)
     {
      Rampa();
     }
 if(A > branco && B < preto)
     {
      Esquerda2();
     }
 if(A < preto && B > branco)
     {
      Direita2();
     }
 if(A < preto && B < preto || A == 255 && B == 255
 || A > 110 && A < 145 && B > 110 && B < 145)
 {
 while(A < preto && B < preto || A == 255 && B == 255
    || A > 110 && A < 145 && B > 110 && B < 145){
       Rampa();
       Wait(1000);
       Parar();
       Wait(10);}//fim do while.
       lerDistancia();
       if(Ultra == 0){
       ResInicio();}
     }
  lerDistancia();
  }

//--- Fim da função do seguidor da rampa ---
//======================================================================================

//======================================================================================
//--- Função principal com loop infinito para controle de todo robô ---

task main(){
    Garra_S();
    Wait(1300);
    Garra_P();
    lerSensorDeLinha();
      
    while(true){

    //---Leituras-Sensores---
    lerSensorDeLinha();
    lerResgate();
    lerDistancia();

    //---Desvio---
    if(Resgate == 0){
    int x = Random(2);
    if(x == 0){
    desvioDireita();}
    else if(x == 1){
    desvioEsquerda();}
    }

    //---Rampa-Resgate---
    if(Ultra == 1){
    while(Ultra == 1){
    seguidorRampa();}//fim do 1 while
    if(Ultra == 0 || Ultra == 1){
    while(Ultra == 0 || Ultra == 1){
    seguidorRampa();}//fim do 2 while
    }//fim do 2 if
    }//fim do 1 if

    //---Seguidor Normal/Verdes---
    seguidorVerde();
 }
}
//--- Fim da função principa de controle do robô ---
//======================================================================================
